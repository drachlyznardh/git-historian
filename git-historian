#!/usr/bin/python

from subprocess import check_output
import re

class Node:
	def __init__ (self):
		self.hash = ""
		self.parent = []
		self.child = []
		self.ref = []
		self.column = -1
		self.static = 0
		self.printed = 0
		self.done = 0

	def print_graph(self, commit_map):
		if self.printed: return
		self.printed = 1

		for i in self.child:
			commit_map[i].print_graph(commit_map)
		print("%s" % self.to_oneline())
		for i in reversed(self.parent):
			commit_map[i].print_graph(commit_map)

	def to_oneline(self):
		if self.column > 0:
			offset = ('%%%ds' % (2 * self.column) % '')
		else: offset = ''
		if self.static: t = 'St'
		else: t = 'Dy'
		return "%s(%02d) %s* %s" % (t, self.column, offset, self.hash)

	def to_string(self):
		if self.column > 0:
			indent = ('%%%ds' % (2 * self.column)) % (' ')
		else: indent = ''
		str = "%s  Hash {%s}" % (indent, self.hash)
		for i in self.parent: str += "\n%sParent {%s}" % (indent, i)
		for i in self.child:  str += "\n%s Child {%s}" % (indent, i)
		for i in self.ref:    str += "\n%s   Ref {%s}" % (indent, i)
		return str

	def know_your_children(self, child):
		if child not in self.child:
			self.child.append(child)

	def know_your_parents(self, commit_map):
		for i in self.parent:
			parent = commit_map[i]
			if parent:
				parent.know_your_children(self.hash)

	def know_your_column (self):
		if len(self.ref):
			for i in self.ref:
				if re.match(r'''^tag: r[0-9]+''', i):
					self.static = 1
					self.column = 1
					break
				if re.match(r'''^tag: h[0-9]+''', i):
					self.static = 1
					self.column = 0
					break
		return self.static

	def inherit_column (self, commit_map, base):
		if self.column != -1: return
		if len(self.ref):
			for i in self.ref:
				if re.match(r'''^tag: r[0-9]+''', i):
					self.static = 1
					self.column = 3
					break
				if re.match(r'''^tag: h[0-9]+''', i):
					self.static = 1
					self.column = 2
					break
		if not self.static: self.column = base

		counter = self.column
		for i in self.child:
			commit_map[i].inherit_column(commit_map, counter)
			counter += 1

		counter = self.column
		for i in self.parent:
			commit_map[i].inherit_column(commit_map, counter)
			counter += 1

class Order:
	def __init__ (self, first):
		self.stack = [[first]]

	def trim(self):
		while len(self.stack) > 0 and len(self.stack[0]) == 0:
			self.stack.pop(0)

	def get(self):
		self.trim()
		if len(self.stack) > 0 and len(self.stack[0]) > 0:
			return self.stack[0][0]
		return None

	def pop(self):
		self.trim()
		if len(self.stack) > 0 and len(self.stack[0]) > 0:
			return self.stack[0].pop(0)
		return None

	def push(self, value):
		if len(self.stack) > 0:
			self.stack[0].append(value)
		else:
			self.stack.append([value])
	
	def ppush(self, value):
		self.stack.insert(1, [value])

	def cpush(self, value):
		self.stack.insert(0, [value])

	def show(self):
		self.trim()
		message = ''
		for i in self.stack:
			if len(i):
				message += '\t[' + i[0][:7]
				for ii in i[1:]:
					message += ", " + ii[:7]
				message += ']\n'
		print "{\n%s}" % message

class Columns:
	def __init__ (self, size):
		self.stack = []
		while len(self.stack) < size:
			self.stack.append(' ')
		self.nextstack = self.stack

	def assign (self, allcommit, commit):
		if commit.column == -1:
			if len(commit.child):
				child = allcommit[commit.child[0]]
				if child:
					if len(child.parent) == 1:
						commit.column = child.column
					elif child.parent[0] == commit.hash:
						commit.column = child.column
					else:
						commit.column = child.column + 1
				#commit.column = allcommit[commit.child[-0]].column
			elif len(commit.parent):
				commit.column = allcommit[commit.parent[-0]].column

		if commit.column == -1:
			commit.column = len(self.stack)

		actual = commit.column * 2

		while len(self.stack) <= actual:
			self.stack.append(' ')

		if actual:
			self.stack[actual - 1] = ' '
		self.stack[actual] = commit

	def show (self, target):
		message = ''
		for i in self.stack:
			if isinstance(i, basestring):
				message += i
			elif i.hash == target:
				message += '*'
			else: message += ' '
		return message

class Historian:
	def __init__ (self):
		self.head = 0
		self.commit = {}
		self.vertical = []
	
	def get_history(self):
		git_history_dump = check_output(["git", "log", '--pretty="%H %P%d"', "--all"])

		for line in git_history_dump.split('\n'):
			if len(line) == 0: continue

			hashes_n_refs = re.compile(r'''"(.*) \((.*)\)"''').match(line)
			if hashes_n_refs:
				hashes = hashes_n_refs.group(1).split()
				refs = hashes_n_refs.group(2).split(',')
			else:
				hashes = line[1:-1].split()
				refs = ""

			node = Node()
			if hashes:
				node.hash = hashes[0]
				for i in hashes[1:]: node.parent.append(i)
			for i in refs: node.ref.append(i.strip())

			if not self.head: self.head = node.hash
			self.commit[node.hash] = node
	
	def all_in_one_call(self, debug):

		self.unroll_vertically(debug)
		self.unroll_horizontally(debug)

		for i in self.vertical:
			print "%s" % self.commit[i].to_oneline()

	def unroll_vertically(self, debug):
		
		visit = Order(self.head)
		columns = Columns(2)
		q = [] # list of all commits which are waiting for their column
		active = 2 # default column is the first with no fixed priority

		while 1:

			target = visit.pop()
			if not target:
				if debug: print "No Target"
				break

			commit = self.commit[target]
			if not commit:
				if debug: print "No Commit"
				break
			if commit.done:
				if debug: print "%s is done, skipping" % commit.hash[:7]
				continue

			if len(commit.child) > 1:
				skip = 0
				for i in reversed(commit.child):
					child = self.commit[i]
					if child and not child.done:
						visit.cpush(i)
						skip = 1
				if skip: continue
			elif len(commit.child) > 0:
				child = self.commit[commit.child[0]]
				if child and not child.done:
					visit.cpush(commit.child[0])
					continue
			'''
			active -= len(commit.child)
			active += len(commit.parent)

			if not commit.know_your_column():
				children = len(commit.child)
				if children == 0:
					commit.column = 2#active
					#print "No child"
				elif children == 1:
					child = self.commit[commit.child[0]]
					if child:
						commit.column = child.column
						#commit.column = len(child.parent)
						#commit.column = 2
						for i in child.parent:
							if commit.hash == i: break
							commit.column += 1
					else: commit.column = active
					#print "One child"
				else:
					column = []
					for i in commit.child:
						child = self.commit[i]
						if child.parent[0] == commit.hash:
							column.append(child.column)
					commit.column = min(column)
					#print "Many children %s %d" % (column, commit.column)
			'''
			#print "%s" % commit.to_oneline()
			self.vertical.append(commit.hash)

			#columns.assign(self.commit, commit)
			#print "%s %s %d" % (columns.show(commit.hash), commit.hash[0:7], len(commit.parent))

			if len(commit.parent) > 1:
				for i in commit.parent:
					parent = self.commit[i]
					if parent and not parent.done:
						visit.ppush(i)
						#active += 1
			elif len(commit.parent) > 0:
				parent = self.commit[commit.parent[0]]
				if parent and not parent.done:
					visit.push(commit.parent[0])
					#active += 1
			
			if debug: visit.show()
			commit.done = 1

	def unroll_horizontally(self, debug):
		
		#base = self.commit[self.head]

		#while len(base.parent):
		#base = self.commit[base.parent[0]]

		#print "%s is the left-most base" % base.hash

		visit = Order(self.head)
		direction = 1 # DOWN
		counter = 0
		for i in self.commit:
			self.commit[i].done = 0
			self.commit[i].know_your_column()

		while 1:

			visit.show()
			target = visit.pop()
			if not target:
				if debug: print "H No Target"
				break

			commit = self.commit[target]
			if not commit:
				if debug: print "H No Commit"
				break
			if commit.done:
				if debug: print "H %s is done, skipping" % commit.hash[:7]
				continue

			if direction: # GOING DOWN TO FIND BASE

				print "V H processing %s" % commit.hash[:7]

				while len(commit.parent):
					for name in commit.parent:
						parent = self.commit[name]
						if not parent.done:
							commit = parent
							break

					visit.cpush(commit.hash)
					direction = 0
				#print "%s is a base" % commit.hash

			print "^ H processing %s" % commit.hash[:7]

			missing_children = len(commit.child)
			for name in commit.child:
				child = self.commit[name]
				if child:
					if child.done:
						missing_children -= 1
					else:
						print "^ H calling child %s" % child.hash[:7]
						visit.cpush(name)
						break
				else:
					missing_children -= 1
						
			if missing_children: continue
			
			commit.know_your_column()
			commit.done = 1

			for name in commit.parent:
				parent = self.commit[name]
				if parent and not parent.done:
					print "v H calling parent %s" % parent.hash[:7]
					visit.ppush(name)

			'''
			if not commit.static:
				parents = len(commit.parent)
				if parents == 0:
					commit.column = 1
				elif parents == 1:
					name = commit.parent[0]
					parent = self.commit[name]
					if parent: commit.column = parent.column
					else: commit.column = 1
				else:
					available = []
					for name in commit.parent:
						parent = self.commit[name]
						if parent: available.append(parent.column)
					commit.column = min(available)

			children = len(commit.child)
			if children == 1:
				name = commit.child[0]
				child = self.commit[name]
				if child and not child.done:
					visit.cpush(name)
					continue
			elif children > 1:
				skip = 0
				for name in reversed(commit.child):
					child = self.commit[name]
					if child and not child.done:
						visit.cpush(name)
						skip += 1
				if skip: continue
			'''

	def tell_the_story(self):

		if not self.commit:
			self.get_history()

		for i in self.commit:
			self.commit[i].know_your_parents(self.commit)
			#self.commit[i].know_your_column()
	
		if self.head:
			self.all_in_one_call(0)
			#self.commit[self.head].inherit_column(self.commit, 2)
			#self.commit[self.head].print_graph(self.commit)

historian = Historian()
historian.tell_the_story()

